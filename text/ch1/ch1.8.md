## 1.8. Процедурные абстракции

Написанная в прошлой главе функция `our_sqrt()` -- пример вычислительного процесса, определяемого 
цепочкой взаимно-определённых процедур (далее программное описание вычислительного процесса будет 
называться "процедурой", чтобы отличать его от математического понятия функции). Определение 
процедуры `sqrt_iter()` является *рекурсивным*, т.е. процедура определяется в терминах самой себя. 
Такие определения, хоть и выглядят странными на первый взгляд, могут быть полезным инструментом 
для многих задач. Подробнее о рекурсивных процедурах будет речь в следующих главах. Сейчас 
рассмотрим подробнее другие особенности, демонстрируемые примером вычисления квадратного корня.

Как можно увидеть, задача вычисления квадратного корня естественным образом делится на несколько 
подзадач: как понять, что приближение достаточно хорошее, как улучшить приближение и т.д. Каждая 
из таких подзадач выполняется своей процедурой. Вся программа может быть представлена как 
взаимосвязанная система процедур, структура которой отражает разбиение на подзадачи:
```
           our_sqrt
              |
          sqrt_iter
          /       \
  is_good_guess   improve
      /    \
 square    abs
```
Разбиение сложной программы на функциональные составные части представляет ценность тем, что каждая 
из частей решает чётко поставленную задачу и может использоваться как модуль для определения других 
процедур. К примеру, когда в процедуре `is_good_guess()` вызывается процедура `square()`, мы можем 
рассматривать процедуру `square()` как "чёрный ящик". Нам несущественно то *каким образом* она 
вычисляет результат, важен только тот факт, что она возвращает квадрат своего аргумента. В этом смысле, 
для процедуры `is_good_guess()` важна не процедура `square()` как конкретный вычислительный процесс, 
а *процедурная абстракция* вычисления квадрата числа. Любая процедура, которая вычисляет квадрат 
каким-либо способом, с точки зрения `is_good_guess()` будет одинаково хороша.

В частности, можно предложить следующие варианты написания `square()` на kerboscript:
```
function square {
  parameter x.
  return x * x.
}

function square {
  parameter x.
  return x^2.
}

function square {
  parameter x.
  return constant:e^(double(ln(x))).
}

function double {
  parameter x.
  return x + x.
}
```
(здесь использован встроенный оператор `^` для возведения в степень, `constant:e` -- встроенное 
определение основания натурального логарифма и встроенная функция `ln()`, вычисляющая натуральный 
логарифм положительного числа).

Написание процедур, которые можно использовать, не зная их внутренней реализации, крайне важно для 
практического программирования. Вы можете использовать процедуры, написанные другими программистами, 
или, наоборот, давать другим программистам написанные вами процедуры. В этом случае программист 
должен не должен знать, как функция реализована внутри, чтобы иметь возможность её использовать.

## Локальные определения

Сейчас мы разберём более детально вопрос, который был затронут в [главе 1.4](ch1.4.md).

Одна из вещей, которая не должна тревожить пользователя процедуры, -- это то, какие имена 
используются в её реализации для обозначения формальных параметров. В частности, такие две процедуры 
с точки зрения пользователя не должны различаться:
```
function square {
  parameter x.
  return x * x.
}

function square {
  parameter y.
  return y * y.
}
```
Этот принцип выглядит довольно очевидным, но имеет глубокие последствия. Например, рассмотрим 
определение `is_good-guess()` из предыдущей главы:
```
function is_good_guess {
  parameter guess, x.
  return abs(square(guess) - x) < 0.0001.
}
```
У приведённой процедуры `guess` является первым аргументом, а `x` -- вторым. Аргумент, с 
которым вызывается функция `square` -- это `guess`. Если, предположим, в реализации процедуры 
`square()` формальный параметр обозначен как `x`, то это значит, что при вычислении выражения 
`square(guess) - x` значение `x` "внутри" процедуры `square()` при вычислении `square(guess)` будет 
отличаться от значения `x` внутри вызывающей эту команду процедуры `is_good_guess()`. Также, 
очевидно, вычисление `square()` не должно влиять на значение `x` внутри `is_good_guess()`, т.к. 
оно может использоваться после того, как значение `square()` уже вычислено.

Если бы имена аргументов не были локальными по отношению к процедуре, где они используются, то 
параметры с одинаковыми именами в различных процедурах могли бы перепутаться, а значит, поведение 
`is_good_guess()` могло бы стать зависимым от деталей внутренней реализации процедуры `square()`, 
и об использовании функций как "чёрных ящиков" не могло бы быть и речи.

Формальный параметр процедуры обладает тем свойством, что для вычисления несущественно, какое 
имя для него использовал программист: если в определении параметров процедуры и во всём коде её реализации 
заменить имя параметра на другое, на ход и результат вычислений это никак не повлияет. В этом 
случае говорят, что для тела процедуры имена её формальных параметров являются *связанными 
символами*, а определение процедуры *связывает* имена с переданными при вызове значениями. Символы, 
не являющиеся связанными, называются *свободными*. Блок кода, внутри которого некоторое имя является 
связанным, называется *областью видимости* этой пары имя-значение. Областью видимости формальных 
параметров процедуры является, очевидно, блок кода, содержащий тело процедуры.

В определении процедуры `is_good_guess()` связанными символами являются `guess` и `x`. Но есть там 
и свободные символы - это `square`, `abs`, `-` и `<`. Выбранные имена для формальных аргументов 
для на смысл того, что вычисляет `is_good_guess()`, никак не повлияют (если, конечно, они будут отличаться 
от `square`, `abs`, `-` и `<`). В то же время для свободных символов этого нельзя сказать -- 
при введении такого определения мы опирались на то, что `square()` вычисляет квадрат своего 
аргумента, `abs()` -- модуль.

## Локальные определения и блочная структура кода

Пока что рассмотрен один из способов изоляции имен: формальные параметры процедуры локальны по 
отношению к телу процедуры. На примере квадратного корня рассмотрим дополнительные возможности по 
изоляции внутренней структуры процедур. Полное определение, данное в предыдущей главе, таково:
```
function our_sqrt {
  parameter x.
  if x = 0 {
    return 0.
  }
  else {
    return sqrt_iter(x, x).
  }
}

function sqrt_iter {
  parameter x, guess.
  if is_good_guess(guess, x) {
    return guess.
  }
  else {
    return sqrt_iter(x, improve(guess, x)).
  }
}

function is_good_guess {
  parameter guess, x.
  return abs(square(guess) - x) < 0.0001.
}

function improve {
  parameter guess, x.
  return (guess + x / guess) / 2.
}
```
Его изъян в том, что пользователю процедуры `our_sqrt()` важна только эта процедура. Три вспомогательных 
функции только мешают восприятию основного назначения этого кода как целого, а действия, которые они 
выполняют, являются специфическими именно для алгоритма вычисления квадратного корня. Вдобавок к этому, 
пользователь должен также помнить, что в программе присутствуют функции с именами `sqrt_iter`, `is_good_guess` 
и `improve`, и если определить другие функции с такими именами, то перестанет работать `our_sqrt`. Это 
схоже с теми проблемами, которые возникают при использовании глобальных переменных, и особенно остро эти 
проблемы проявляются при работе над большими проектами.

В рамках kerboscript эта проблема имеет решение: определения вспомогательных функций можно сделать локальными 
внутри тела основной функции. Выглядит это следующим образом:
```
function our_sqrt {
  parameter x.

  declare local function sqrt_iter {
    parameter x, guess.

    if is_good_guess(guess, x) {
      return guess.
    }
    else {
      return sqrt_iter(x, improve(guess, x)).
    }
  }
  declare local function is_good_guess {
    parameter guess, x.
    return abs(square(guess) - x) < 0.0001.
  }
  declare local function improve {
    parameter guess, x.
    return (guess + x / guess) / 2.
  }

  if x = 0 {
    return 0.
  }
  else {
    return sqrt_iter(x, x).
  }
}
```
Теперь все вспомогательные процедуры спрятаны внутри реализации основной, что означает, что вне `our_sqrt()` 
процедуры с такими именами могут быть при необходимости определены как угодно. Такие вложенные определения 
составляют *блочную структуру* кода. Теперь, когда вспомогательные процедуры имеют область видимости лишь внутри 
тела основной процедуры, их можно дополнительно оптимизировать: поскольку внутри процедуры `our_sqrt()` имя `x` 
является связанным, его можно не передавать во вспомогательные процедуры как формальный параметр. Вместо этого, 
`x` можно сделать внутри вспомогательных процедур свободной переменной, значение которой будет определяться 
значением аргумента, с которым вызывается `our_sqrt()`. В этом случае говорят, что процедуры `sqrt_iter()`, 
`is_good_guess()` и `improve()` образуют вместе со значением `x` в том окружении, где они создаются, *лексическое 
замыкание*. Подробнее об этом речь пойдёт позднее.
```
function our_sqrt {
  parameter x.

  declare local function sqrt_iter {
    parameter guess.

    if is_good_guess(guess) {
      return guess.
    }
    else {
      return sqrt_iter(improve(guess)).
    }
  }
  declare local function is_good_guess {
    parameter guess.
    return abs(square(guess) - x) < 0.0001.
  }
  declare local function improve {
    parameter guess.
    return (guess + x / guess) / 2.
  }

  if x = 0 {
    return 0.
  }
  else {
    return sqrt_iter(x).
  }
}
```
Подобная организация в виде логических блоков на данный момент является основным средством разделения 
сложных программ на доступные для понимания части практически во всех языках программирования.

[ \>](ch1.8.md)

[\< 1.7. Пример: поиск корней уравнений](ch1.7.md)

[\<\< К оглавлению](../../README.md)
