## 1.9. Чтобы понять рекурсию, нужно понять рекурсию

Примеры из предыдущих глав показали, как пользоваться элементарными процедурами, 
как комбинировать процедуры и как абстрагировать определения внутри процедур через 
локальные объявления. Сейчас рассмотрим ещё некоторые примеры написания функций 
и проанализируем, как устроены порождаемые ими процессы.

## Линейная рекурсия и итерация

Рассмотрим пример вычисления факториала числа:

*n*!&nbsp;=&nbsp;*n*×(*n*-1)×(*n*-2)×…×2×1.

Как можно заметить, факториал можно также определить рекурсивно:

0!&nbsp;=&nbsp;1, для *n*>0 *n*!&nbsp;=&nbsp;*n*×(*n*-1)!

Это определение легко оформить в функцию:
```
function factorial {
  parameter n.
  if n = 0 {
    return 1.
  }
  else {
    return n * factorial(n - 1).
  }
}
```
Процесс вычисления можно представить с помощью подстановочной модели:
```
factorial(5) =
5 * factorial(4) =
5 * (4 * factorial(3)) =
5 * (4 * (3 * factorial(2))) =
5 * (4 * (3 * (2 * factorial(1)))) =
5 * (4 * (3 * (2 * (1 * factorial(0))))) =
5 * (4 * (3 * (2 * (1 * 1)))) =
5 * (4 * (3 * (2 * 1))) =
5 * (4 * (3 * 2)) =
5 * (4 * 6) =
5 * 24 =
120
```
Альтернативный способ вычисления состоит в том, чтобы, создав некоторый 
"аккумулятор", собирать в него произведение последовательных натуральных чисел, 
т.е. производить вычисление шагами, описываемыми следующим правилом:
```
Нужно вычислить: n!

Инициализация:
accumulator = 1, counter = 1

Шаг:
если counter > n, вернуть accumulator
иначе
  accumulator <- counter * accumulator
  counter <- counter + 1
вернуться к началу шага
```
Знак `<-` здесь используется для обозначения того, что значение переменной, 
записанной слева от него, *изменяется* на значение выражения, записанного 
справа. Легко проверить, что записанный алгоритм действительно вычисляет 
факториал *n*.

Вопрос в том, что с процедурой изменения значений переменной мы не знакомы. Каким 
же образом тогда записать этот *итерационный* алгоритм? Ответ состоит в том, что 
процесс, типично описываемый циклом в императивных языках типа Паскаля или Си, можно 
также представить в виде *рекурсивной функции*, аргументами которой являются 
аккумулятор и значение переменной цикла:
```
function factorial_iter {
  parameter n, counter, acc.

  if counter > n {
    return acc.
  }
  else {
    return factorial_iter(n, counter * acc, counter + 1).
  }
}

function factorial {
  parameter n.
  // инициализируем "счётчик цикла"
  // и "аккумулятор"
  declare local starting_acc is 1.
  declare local starting_counter is 1.

  return factorial_iter(n,
                        starting_counter,
                        starting_acc).
}
```
**Упражнение 1.** Перепишите процедуру `factorial()` из определения выше так, чтобы 
функция `factorial_iter()` была определена внутри. Также можно учесть то, что в этом 
случае `n` можно не передавать в `factorial_iter()` как явный параметр, а брать из 
окружения.

В этом случае порождаемый процесс выглядит таким образом:
```
factorial(5) =
factorial_iter(5, 1,   1) =
factorial_iter(5, 2,   1) =
factorial_iter(5, 3,   2) =
factorial_iter(5, 4,   6) =
factorial_iter(5, 5,  24) =
factorial_iter(5, 6, 120) =
120
```

Отличие двух порождаемых процессов состоит в том, что в первом случае имеет место 
*линейная рекурсия*: необходимость выполнить рекурсивный вызов приводит к тому, что 
умножения "откладываются" до завершения полного развёртывания рекурсии. Такое откладывание 
значит, что по мере выполнения рекурсивной процедуры нужно запомнить все эти отложенные 
умножения и значения уже вычисленного аргумента. Из-за этого рекурсивная процедура 
занимает место в *стеке вызовов*, и при большой глубине рекурсии может привести к его 
переполнению. Второй процесс соответствует *хвостовой рекурсии*, которая может быть 
оптимизирована так, чтобы не занимать лишнего места на стеке вызовов (вместо 
добавления ещё одного вызова, соответствующего повышению глубины рекурсии, на стеке 
оставляется та же процедура, но в ней заменяются значения аргументов и указатель команды 
внутри процедуры возвращается в начало выполнения). Впрочем, в kerboscript такая 
оптимизация не делается, и хвостовая рекурсия занимает место в памяти пропорционально 
глубине рекурсии так же, как и линейная. В этом смысле пример приведён, скорее, для 
иллюстрации и для расширения кругозора. Языки, поддерживающие оптимизацию хвостовых 
вызовов -- это, прежде всего, языки функционального программирования (F#, Haskell, Erlang) 
и языки семейства Лисп (Scheme по стандарту, многие реализации Common Lisp). В большинстве 
языков, где основным является императивное программирование, оптимизация хвостовой 
рекурсии не выполняется, поскольку для итерационных процессов можно использовать циклы.

## Древовидная рекурсия

Другой классический пример рекурсивной процедуры -- вычисление чисел Фибоначчи. Классическая 
последовательность Фибоначчи имеет вид

0, 1, 1, 2, 3, 5, 8, 13, 21, и т.д.

Начиная с третьего элемента, каждое число равно сумме двух предыдущих. Т.е.
```
         | 0, если n = 0,
Fib(n) = | 1, если n = 1,
         | Fib(n-1) + Fib(n-2), иначе
```
Буквальный "перевод" этого определения выглядит так:
```
function fib {
  parameter n.
  if n < 2 {
    return n.
  }
  else {
    return fib(n - 1) + fib(n - 2).
  }
}
```
Эта процедура порождает *древовидную рекурсию*:
```
                       ________fib(5)________
                      /                      \
                __fib(4)__                  fib(3)
               /          \                 /    \
          fib(3)          fib(2)       fib(2)   fib(1)
          /    \          /   \        /   \      |
     fib(2)    fib(1) fib(1) fib(0) fib(1) fib(0) 1
     /   \      |       |     |      |      |
 fib(1) fib(0)  1       1     0      1      0
  |       |
  1       0
```
Если процедура входит в рекурсивную ветвь, то она делает сразу два рекурсивных вызова, 
что и приводит к древовидной структуре. Если посчитать число рекурсивных вызовов, то 
видно, что 

*N<sub>calls</sub>*(*n*)&nbsp;=&nbsp;*N<sub>calls</sub>*(*n*-1)+*N<sub>calls</sub>*(*n*-2),

причём *N<sub>calls</sub>*(0)=*N<sub>calls</sub>*(1)=1. Таким образом,

*N<sub>calls</sub>*(*n*)=Fib(*n*+1).

Плохо, однако, в первую очередь, то, что в нарисованном выше дереве большая часть работы 
дублируется: Fib(3) вызывается дважды, Fib(2) -- трижды, Fib(1) -- целых пять раз. Вместе с тем, 
занимаемая память (т.е. чило операций, отложенных до вычисления рекурсивного вызова), растёт 
только линейно с *n*, поскольку аргументы у сложения вычисляются начиная слева по одному:
```
fib(5) =
fib(4) + fib(3) =
(fib(3) + fib(2)) + fib(3) =
((fib(2) + fib(1)) + fib(2)) + fib(3) =
(((fib(1) + fib(0)) + fib(1)) + fib(2)) + fib(3) =
(((1 + fib(0)) + fib(1)) + fib(2)) + fib(3) =
(((1 + 0) + fib(1)) + fib(2)) + fib(3) =
((1 + fib(1)) + fib(2)) + fib(3) =
((1 + 1) + fib(2)) + fib(3) =
(2 + fib(2)) + fib(3) =
(2 + (fib(1) + fib(0))) + fib(3) =
...
```
Т.е. при вычислении "разворачиваются" не все ветки дерева сразу, как на картинке выше, 
а по очереди.

Естественно, более логичным будет организовать итерационный процесс:
```
Надо вычислить: Fib(n).

Инициализация: counter = n,
               a = Fib(1) = 1,
               b = Fib(0) = 0.

Шаг:
если counter = 0, вернуть b
иначе
  a <- a + b,
  b <- a (до изменения)
  counter <- counter - 1
вернуться к началу шага
```

И в виде процедуры это выражается как
```
function fib {
  parameter n.

  declare local function fib_iter {
    parameter a, b, counter.
    if counter = 0 {
      return b.
    }
    else {
      return fib_iter(a + b, a, counter - 1).
    }
  }

  return fib_iter(1, 0, n).
}
```

Несмотря на то, что для вычисления чисел Фибоначчи древовидная рекурсия является 
крайне неэффективным методом, это практически единственный возможный метод обработки 
древовидных структур данных, где она и находит основное применение. В виде дерева, 
например, организована структура деталей в корабле в Kerbal Space Program, 
поэтому для её анализа могут понадобиться древовидно-рекурсивные процедуры.

Глядя на приведённые примеры линейной и древовидной рекурсии, можно сформулировать 
следующие правила, при выполнении которых рекурсивное определение процедуры будет 
корректным, т.е. значение будет вычислено за конечное число вызовов:
* существуют значения аргументов, которые реализуют *базовый случай*; в этом случае возвращаемое значение вычисляется напрямую из значений аргументов без рекурсивного вызова
* значения аргументов при рекурсивном вызове ближе к базовому случаю, чем их значения в том окружении, откуда этот рекурсивный вызов был сделан
* изменения значений аргументов при рекурсии делаются таким образом, чтобы привести аргументы к базовому случаю за конечное число шагов (а не асимптотически, например)

В этом смысле построение рекурсивного метода решения задачи похоже на построение 
доказательства методом *математической индукции*.

## Пример: подсчёт способов размена

Ещё одна классическая задача, приводящая к древовидной рекурсии, но где сведение 
к линейной рекурсии уже неочевидно, -- это подсчёт способов размена некоторой суммы 
набором монет.

Рассмотрим размер некоторой суммы монетами по 1, 2, 5 и 10 рублей. Способ решения 
можно описать таким образом:
* число способов размена суммы *s* равно числу способов разменять *s* всеми типами монет, кроме первого, плюс
* число способов разменять всеми типами монет сумму *s*-*n*, где *n* -- номинал первого типа монет

К этому нужно добавить особые ситуации:
* если сумма *s* равна 0, то есть только один способ её размена
* если сумма *s* меньше нуля, то способов её разменять не существует
* если число типов монет равно 0, то способов размена любой суммы, кроме 0, не существует

Эти правила трансформируются в процедуру:
```
function count_change {
  parameter sum.

  declare local function count_aux {
    parameter sum, ntypes.
    if sum = 0 {
      return 1.
    }
    else if (sum < 0) or (ntypes = 0) {
      return 0.
    }
    else {
      return count_aux(sum, ntypes - 1) + count_aux(sum - first_nominal(ntypes), ntypes).
    }
  }
  declare local function first_nominal {
    parameter ntypes.
    // возвращает номинал самой крупной монеты
    // по заданному числу типов монет
    if ntypes = 4 {
      return 10.
    }
    else if ntypes = 3 {
      return 5.
    }
    else if ntypes = 2 {
      return 2.
    }
    else if ntypes = 1 {
      return 1.
    }
  }

  return count_aux(sum, 4).
}
```
Теперь, чтобы получить число способов разменять, скажем, 100 рублей, нужно в файл с 
определением функции добавить
```
print count_change(100).
```
Ответ `2156` на стандартных настройках kOS получается весьма не сразу. Чтобы дождаться его 
за разумное время, лучше перейти в игровые настройки и во вкладке kOS увеличить параметр 
"Instructions per update" до максимального значения 2000.

[1.10. Процедуры как аргументы \>](ch1.10.md)

[\< 1.8. Процедурные абстракции](ch1.8.md)

[\<\< К оглавлению](../../README.md)
