## 1.5. Побочные эффекты, чистые функции и глобальные переменные

В предыдущей главе приведены примеры написания функций `square(x)` и `hypot(a, b)`, которые показывают, как простые вычисления можно комбинировать 
в более сложные и давать сложным комбинациям отдельное имя. Эти функции относятся к классу так называемых *чистых функций*, что означает, что:
* возвращаемое значение функции зависит только от формальных аргументов
* при одном и том же наборе аргументов возвращаемое значение будет одинаковым вне зависимости от того, в каком окружении и в какое время вызвана функция
* при вычислении функции отсутствуют побочные эффекты, т.е. изменение значений сторонних переменных

Примерами конструкций, не являющимися чистыми функциями, являются `declare` и `print`. В случае `declare` побочным эффектом является изменение 
состояния интерпретатора -- определённый символ начинает иметь какое-то значение. В случае `print` побочный эффект -- изменение состояния терминала 
(появление на нём символов).

Чистые функции имеют особое значение потому, что их легко использовать, комбинировать и отлаживать. Лёгкость использования связана с тем, что 
программисту не нужно задумываться, что вызов функции может неожиданно изменить какую-либо внешнюю (по отношению к функции) переменную или 
привести к изменениям в работе остальной части программы. То же самое приводит к лёгкости комбинирования. В то же время, если обнаружено, что 
комбинация чистых функций работает не так, как ожидается -- то ошибка может быть либо в одной из комбинируемых функций, либо в программировании 
комбинации. Таким образом, отладка чистых функций не требует отладки взаимного влияния функций при использовании их комбинаций.

К взаимному влиянию различных элементов кода может приводить, к примеру, использование одних и тех же глобальных переменных. Это означает, что 
глобальные переменные усложняют отладку программ, и ими необходимо пользоваться с осторожностью. Поскольку они доступны в любом месте программы, 
возможно их случайное использование. Например, такое "неправильное" определение функции `hypot()`
```
function hypot {
  parameter a.
  return sqrt(square(a) + square(b)).
}
```
будет работать, если есть глобально определённая переменная `b`. Что ещё хуже, некоторые выражения могут менять значения переменных, а изменение 
глобальной переменной может повлиять на другие части программы непредвиденным образом.

В силу этого, глобальными переменными лучше пользоваться только для задания каких-либо констант и внутри программы их не менять. Чтобы при объявлении 
любой переменной внутри файла требовалось явно указывать, является она локальной или глобальной, рекомендуется вначале любого файла писать директиву
```
@lazyglobal off.
```
Таким образом можно быть уверенным, что глобальная переменная не будет случайно создана командой присваивания `set` (применение и необходимость которой 
будет рассмотрена позднее).

Некоторые глобальные переменные создаются при загрузке kOS. Задание тех же самых имён для пользовательских переменных может приводить к непредсказуемым 
последствиям, поэтому со списком этих переменных стоит ознакомиться на [странице документации](https://ksp-kos.github.io/KOS/bindings.html) и учитывать при написании программ.

[1.6. Условные выражения и логические функции \>](ch1.6.md)

[\< 1.4. Создание собственных функций. Окружения и видимость переменных](ch1.4.md)

[\<\< К оглавлению](../../README.md)
