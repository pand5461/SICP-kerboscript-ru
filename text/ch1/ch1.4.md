## 1.4. Создание собственных функций. Окружения и видимость переменных

Итак, мы увидели, что программисту на kerboscript доступен 
некоторый уровень абстракции в виде *связывания* имён со значениями. Более мощным уровнем абстракции 
является связывание имён с процедурой вычислений, т.е. определение собственных функций. 

Рассмотрим синтаксис определения функции на примере возведения в квадрат. Словесным описанием вычисления 
будет: "возведение числа в квадрат есть умножение числа на само себя". Синтаксис будет следующим: 
```
declare function square {
  parameter x.
  return x * x.
}
```

Связывание функции начинается с ключевых слов `declare function` (`declare` на самом деле можно опустить, 
что будет сделано в дальнейших примерах), затем идёт имя функции `square`, далее внутри фигурных скобок идёт 
*тело функции*.

Т.к. мы хотим, чтобы функция имела *аргумент* в виде числа, то это нужно указать в начале тела функции словом 
`parameter`. Параметр даётся некоторые имя, которым его можно называть внутри функции. Значение функции возвращается 
ключевым словом `return`.

Теперь, если эта функция была введена в терминале, то можно посмотреть на её работу, набрав
```
> print square(12).
144
```

Если функция была определена в файле, то она будет недоступна для вызова в терминале даже если файл был запущен командой 
`runpath()` из-за ограничений реализации языка. Команда печати для просмотра результата и тестирования в этом случае должна 
быть написана внутри того же файла, где определена функция.

С определениями функций и привязкой имён к аргументам связан вопрос окружений для вычисления символов. Предположим, что 
у нас есть файл с такими командами:

```
declare global x is 42.

function hello {
  print "Hello, " + x.
}

function hellox {
  parameter x.
  print "Hello, " + x.
}

hello().
hellox("world").
```

(функции в этом случае не имеют выражений `return` в явном виде, поэтому возвращаемым значением по умолчанию будет являться 0; 
в данном примере возвращаемые значения не важны, интересует вывод выражений на экран).

Как видно, функции производят одинаковое действие `print "Hello, " + x.` Результат, однако, будет разным, поскольку для функции 
`hello()` значение `x` будет взято из *глобального окружения* и будет равно 42, а для `hellox(x)` значение "перезаписывается" именем 
аргумента и будет равно строке "world".

Говорят, что внутри определения функции или любого другого выражения, выделенного по желанию программиста фигурными скобками, создаётся 
*локальное окружение*, в котором можно произвольно определить значения переменных. В этом случае для выражений, записанных внутри 
такого локального окружения, для вычисления переменных будет сначала проверяться, определена ли переменная с таким именем в локальном окружении 
и если да, то будет браться именно значение *локальной* переменной. Если же такое имя в локальном окружении не найдено, то поиск ведётся в 
окружении на уровень выше и т.д. вплоть до глобального окружения. Если имя символа не найдено ни на одном из уровней, выдаётся ошибка, что 
переменная не определена.

[\< 1.2. Особенности работы с терминалом и файлами](ch1.2.md)

[\<\< К оглавлению](../../README.md)
