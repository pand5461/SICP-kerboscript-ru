## 1.4. Создание собственных функций. Окружения и видимость переменных

Итак, мы увидели, что программисту на kerboscript доступен 
некоторый уровень абстракции в виде *связывания* имён со значениями. Более мощным уровнем абстракции 
является связывание имён с процедурой вычислений, т.е. определение собственных функций. 

Рассмотрим синтаксис определения функции на примере возведения в квадрат. Словесным описанием вычисления 
будет: "возведение числа в квадрат есть умножение числа на само себя". Синтаксис будет следующим: 
```
declare function square {
  parameter x.
  return x * x.
}
```

Связывание функции начинается с ключевых слов `declare function` (`declare` на самом деле можно опустить, 
что будет сделано в дальнейших примерах), затем идёт имя функции `square`, далее внутри фигурных скобок идёт 
*тело функции*.

Т.к. мы хотим, чтобы функция имела *аргумент* в виде числа, то это нужно указать в начале тела функции словом 
`parameter`. Параметр даётся некоторые имя, которым его можно называть внутри функции. Значение функции возвращается 
ключевым словом `return`.

Теперь, если эта функция была введена в терминале, то можно посмотреть на её работу, набрав
```
> print square(12).
144
```

В качестве аргумента функции можно передавать и вычисляемое выражение:
```
print square(2+2). // напечатает 16
print square(square(3)). // напечатает 81
```
(всё, что идёт в строке после `//`, kerboscript интерпретирует как комментарий и игнорирует при чтении и исполнении 
файлов и команд терминала).

Теперь эту функцию можно использовать для дальнейшего комбинирования вычислений. Например, гипотенуза прямоугольного треугольника 
с катетами `a` и `b` равна по теореме Пифагора `sqrt(a^2 + b^2)`. Используя наше определение `square(x)`, мы можем записать 
такую функцию:
```
function hypot {
  parameter a, b.
  // возвращает длину гипотенузы прямоугольного треугольника
  // с катетами a и b
  return sqrt(square(a) + square(b)).
}
```

Можем проверить эту функцию:
```
print hypot(3, 4). // напечатает 5
print hypot(hypot(3, 4), 3 * 4). // напечатает 13
```

Использование функций в терминале kOS имеет ограничения, из-за чего в этом руководстве и рекомендуется пользоваться файлами. 
Если функция была определена в файле, то она будет недоступна для вызова в терминале даже если файл был запущен командой 
`runpath()` из-за ограничений реализации языка. Команда печати для просмотра результата и тестирования в этом случае должна 
быть написана внутри того же файла, где определена функция.

С определениями функций и привязкой имён к аргументам связан вопрос окружений для вычисления символов. Предположим, что 
у нас есть файл с такими командами:

```
declare global x is 42.

function hello {
  print "Hello, " + x.
}

function hellox {
  parameter x.
  print "Hello, " + x.
}

hello().
hellox("world").
```

(функции в этом случае не имеют выражений `return` в явном виде, поэтому возвращаемым значением по умолчанию будет являться 0; 
в данном примере возвращаемые значения не важны, интересует вывод выражений на экран).

Как видно, функции производят одинаковое действие `print "Hello, " + x.` Результат, однако, будет разным, поскольку для функции 
`hello()` значение `x` будет взято из *глобального окружения* и будет равно 42, а для `hellox(x)` значение "перезаписывается" именем 
аргумента и будет равно строке "world".

Говорят, что внутри определения функции или любого другого выражения, выделенного по желанию программиста фигурными скобками, создаётся 
*локальное окружение*, в котором можно произвольно определить значения переменных. В этом случае для выражений, записанных внутри 
такого локального окружения, для вычисления переменных будет сначала проверяться, определена ли переменная с таким именем в локальном окружении 
и если да, то будет браться именно значение *локальной* переменной. Если же такое имя в локальном окружении не найдено, то поиск ведётся в 
окружении на уровень выше и т.д. вплоть до глобального окружения. Если имя символа не найдено ни на одном из уровней, выдаётся ошибка, что 
переменная не определена.

Имена переменных, обозначенные как `parameter` попадают в *локальное окружение* тела функции, и вне своих функций эти имена могут быть связаны 
с другими значениями или не связаны ни с каким значением. Аналогичным образом можно создавать локальное связывание имён переменных для произвольного 
окружения. Для этого используется команда `declare local` (как можно догадаться, `declare global`, в отличие от неё, помещает имя сразу в глобальное 
окружение). Границы локального окружения обозначаются фигурными скобками, а также определения внутри любого файла попадают в локальное для этого файла 
окружение.

Рассмотрим пример. Создадим файл такого содержания:
```
declare local x is 42.

{
  declare local x is 24.
  print "X in the local environment is " + x.
}

print "X in the per-file environment is " + x.
```

Запуск этого файла показывает, что внутри фигурных скобок `x` равен 24, а за их пределами -- 42, что похоже на случай с аргументом функции.

[1.5. Побочные эффекты, чистые функции и глобальные переменные \>](ch1.5.md)

[\< 1.3. Правила вычисления выражений](ch1.3.md)

[\<\< К оглавлению](../../README.md)
