## 1.6. Условные выражения и логические функции

Пока что все рассмотренные конструкции языка были ограничены тем, что они не могли 
проверять какое-либо условие и выполнять различные действия в зависимости от того, 
истинно это условие или нет. В качестве примера, когда это может пригодиться, можно 
рассмотреть функцию, возвращающую знак аргумента (в оригинале SICP рассматривается функция 
модуля `abs(x)`, но она является стандартной в kOS):
```
            |  1, если x > 0,
signum(x) = |  0, если x = 0,
            | -1, если x < 0.
```
Такая конструкция называется *разбором случаев*. Для неё используется *особый оператор*, 
называемый условным оператором. Выглядит это следующим образом:
```
function signum {
  parameter x.
  if x > 0 {
    return 1.
  }
  else if x = 0 {
    return 0.
  }
  else {
    return -1.
  }
}
```
Работает это следующим образом. Проверяется условие, написанное после `if`. Если оно 
истинно, то выполняется блок программы в фигурных скобках после условия. Если же оно не 
выполняется, то программа переходит к блоку после `else`, игнорируя `if`-блок кода. Сразу 
после `else` может идти новое условие `if`, которое проверяется по тем же правилам, что и 
первое. Когда все явные условия выписаны, может быть записан последний блок `else`, код в 
котором выполнится, если ни одно из условий не выполнено, либо же `else` может отсутствовать, 
тогда в случае невыполнения ни одного из условий никакой код вызываться не будет.

Особым оператором `if-else` конструкцию можно назвать по той причине, что в зависимости от 
выполнения или невыполнения условия функция не только возвращает разные значения, но и 
выполняет *различный набор операций*. Если рассматривать условия и блоки кода для выполнения 
как аргументы условного оператора, то его поведение отличается от поведения функций, которые 
могут быть определены программистом: в пользовательских функциях все аргументы вычисляются 
прежде, чем к ним применяется функция, а в `if-else` в зависимости от значения первого аргумента 
(`True` или `False`) вычисляется лишь один из следующих.

В качестве примера невозможности подобного поведения пользовательской функции попробуем написать 
функцию, которая возвращает второй аргумент, если первый является истинным, и третий, если 
первый является ложным.
```
function choose {
  parameter condition, consequent, alternative.
  // возвращает consequent, 
  // если condition выполняется (= True),
  // и alternative в противном случае
  if condition {
    return consequent.
  }
  else {
    return alternative.
  }
}
```
Проверим эту функцию на следующих примерах:
```
declare local x is -2.
print choose(x > 0, x, -1 * x). // печатает 2
print choose(x+2 = 0, "x равно -2", "x не равно -2"). // печатает "x равно -2"
```

Всё выглядит нормально, но вот если попробовать вызвать
```
print choose(x+2 = 0, 0, 1 / (x+2)).
```
то программа вылетит с ошибкой "попытка положить бесконечность в стек". Ошибка 
вызывается тем, что при вычислении функции `choose()` интерпретатор сначала пытается 
вычислить все аргументы, хотя значение одного из них в дальнейшем и не существенно.

Теперь рассмотрим, что можно передать в `if-else` в качестве проверяемого условия. Начать 
следует с того, что в качестве логических значений могут использоваться не только `True` и 
`False`, но и числа. При этом число `0` считается "ложью", а любое другое число -- "истиной".

Также различные логические значения можно комбинировать с помощью логических функций. 
Доступны логические функции `and` (и) `or` (или) и `not`(не). Как обычно, `and` возвращает 
истину только тогда, когда оба аргумента истинны, `or` -- когда хотя бы один из аргументов 
истинный, а `not` инвертирует значение аргумента.

Также есть встроенные функции, возвращающие логические значения:
* `>`, `>=`, `<`, `<=` -- сравнение
* `=` -- проверка на равенство (не присваивание!)
* `<>` -- проверка на неравенство

Логические функции `and` и `or` вычисляются по особым правилам, реализуя так называемые 
"закороченные" логические вычисления. Это означает, что `x and y` при ложном `x` возвращает 
`False`, не вычисляя `y`. Аналогично, `x or y` при истинном `x` возвращает `True` без 
вычисления `y`. В этом можно убедиться, запустив следующий код:
```
declare local x is 0.
print ((x = 0) or (1 / x = 0)).  // печатает True
print ((x<>0) and (1 / x <> 0)). // печатает False
```
В случае обычных правил вычисления, как мы помним, должна произойти попытка вычислить `1/x`, 
приводящая к ошибке.

Далее рассмотрим, насколько далеко в написании программ можно зайти, имея в арсенале только те 
конструкции, которые к этому моменту разобраны.

**Упражнение**. Написать функцию, которая принимает аргументами три числа и возвращает сумму квадратов 
двух наибольших из них.

[1.7. Пример: поиск корней уравнений \>](ch1.7.md)

[\< 1.5. Побочные эффекты, чистые функции и глобальные переменные](ch1.5.md)

[\<\< К оглавлению](../../README.md)
