## 1.7. Пример: поиск корней уравнений

Как мы увидели, функции, определяемые в программировании, во многом похожи на математические 
функции -- они ставят в соответствие своим аргументам некоторое значение. Однако, есть 
существенное отличие функций в программировании от функций в математике -- первые должны быть 
*конструктивными*.

Рассмотрим этот вопрос на примере вычисления квадратного корня, если в арсенале имеются только 
четыре основных арифметических действия.

Математически функцию квадратного корня можно описать следующим образом:
```
Квадратный корень из неотрицательного числа X -- это такое неотрицательное число Y, что Y * Y = X.
```
Математикам такого определения достаточно, чтобы доказать существование и единственность квадратного 
корня, а также выводить другие его свойства и пользоваться квадратным корнем, как обычной функцией.

С конструктивной точки зрения, однако, это определение говорит нам, как *проверить*, является ли 
одно число квадратным корнем из другого, но не говорит, как *вычислить* квадратный корень из числа. 
Определение не даёт возможности, зная число, *сконструировать* квадратный корень из него, т.е. не 
является конструктивным.

Как же, зная число, вычислить квадратный корень из него? Из определения мы видим, что если 
*sqrt*(*x*)&nbsp;=&nbsp;*y*, то *y*\**y*&nbsp;=&nbsp;*x*. Из этого можно попытаться 
найти *y* *методом неподвижной точки*. Метод состоит в том, чтобы преобразовать уравнение к 
виду *y*&nbsp;=&nbsp;*f*(*y*) и, начав с какой-то приблизительной оценки ответа, вычислять 
*y*<sub>*k*+1</sub>&nbsp;=&nbsp;*f*(*y<sub>k</sub>*) до тех пор, пока последовательные приближения 
не перестанут различаться между собой. Это похоже на то, что мы ввели в калькуляторе какое-то 
число и нажимаем одну и ту же кнопку, например, `cos`, до тех пор, пока цифры на экране не 
перестанут меняться. 

Для квадратного корня можно довольно легко сконструировать преобразование неподвижной точки: 
если *y*\**y*&nbsp;=&nbsp;*x*, то *y*&nbsp;=&nbsp;*x*/*y*. К сожалению, такой метод работать 
не будет, поскольку при первом применении мы получим *y*<sub>1</sub>&nbsp;=*x*/*y*<sub>0</sub>, 
затем *y*<sub>2</sub>&nbsp;=*x*/*y*<sub>1</sub>&nbsp;=&nbsp;*x*/(*x*/*y*<sub>0</sub>)&nbsp;=&nbsp;*y*<sub>0</sub>,
и значения будут всё время перескакивать между двумя числами.

Однако, можно попробовать сделать какое-либо другое преобразование с неподвижной точкой, для 
которого описанная процедура будет сходиться. Относительно простым будет следующее: если 
*y*&nbsp;=&nbsp;*x*/*y*, то *y* будет равно и среднему между *y* и *x*/*y*, т.е. можно попробовать 
провести уточнение приближений по формуле *y*<sub>*k*+1</sub>&nbsp;=&nbsp;(*y<sub>k</sub>*&nbsp;+&nbsp;*x*/*y<sub>k</sub>*)/2.
Этот процесс, как оказывается, действительно сходится к квадратному корню из *x* из любого положительного 
начального приближения. Например, так выглядят итерации при вычислении квадратного корня из 2 
с начальным приближением *y<sub>0</sub>*&nbsp;=&nbsp;1:

| Приближение | Частное | Среднее |
|:-----------:|---------|-------- |
| 1 | 2/1 = 2 | (1+2)/2 = 1.5 |
| 1.5 | 2/1.5 = 1.3333 | (1.5+1.3333)/2 = 1.4167 |
| 1.4167 | 2/1.4167 = 1.4117 | (1.4167+1.4117)/2 = 1.4142 |
| 1.4142 | 2/1.4142 = 1.4142 | (1.4142+1.4142)/2 = 1.4142 |

Пример показывает, что всего за 4 итерации метод сходится до 4 знаков после запятой.

Напишем общую процедуру получения корня уравнения:
* начать с некоторого приближения
* проверить, достаточно ли оно хорошее
* если приближение устраивает, то вернуть его как ответ, иначе -- вычислить более точное приближение по заданному алгоритму
* начать всю процедуру заново, используя уточнённое значение как искомое приближение

В виде кода это будет выглядеть таким образом:
```
function sqrt_iter {
  parameter x, guess.
  // вычисляет квадратный корень из x,
  // guess -- текущее приближение
  if is_good_guess(guess, x) {
    return guess.
  }
  else {
    return sqrt_iter(x, improve(guess, x)).
  }
}
```
Как видно, функция представляет собой ветвление на два варианта: если приближение, которое 
передано в качестве аргумента, признаётся хорошим -- оно возвращается как результат. В 
противном случае нужно вернуть результат вычисления *той же самой функции*, но с уточнённым 
значением приближения.

Чтобы функция работала, нужно определить вспомогательные функции `is_good_guess(guess, x)`, 
которая определяет, устраивает ли нас `guess` как приближение к квадратному корню из `x`, и 
`improve(guess, x)`, которая возвращает уточнённое приближение на основе более грубого.

Согласно описанной итерационной процедуре, уточнение производится следующим образом:
```
function improve {
  parameter guess, x.
  return (guess + x / guess) / 2.
}
```

"Хорошее приближение" к квадратному корню из `x` можно, например, определить как число, квадрат 
которого отличается от `x` не более чем на 0.0001:
```
function is_good_guess {
  parameter guess, x.
  return abs(square(guess) - x) < 0.0001.
}
```
Встроенная функция `abs()` возвращает модуль своего аргумента, т.е. проверка будет выполнена, 
если `-0.0001 < square(guess) - x < 0.0001`. Функция `square()`, написанная в [главе 1.4](ch1.4.md), 
возвращает квадрат своего аргумента.

Поскольку вызывать функцию квадратного корня с двумя аргументами неудобно, сделаем функцию, которая 
принимает один аргумент и вызывает `sqrt_iter()` с этим же аргументом в качестве начального приближения. 
Также добавим *x*&nbsp;=&nbsp;0 как особый случай, поскольку для него квадратный корень известен.
```
function our_sqrt {
  parameter x.
  if x = 0 {
    return 0.
  }
  else {
    return sqrt_iter(x, x).
  }
}
```
Можно проверить эту функцию, вызвав:
```
print our_sqrt(9). // печатает 3.00000000139698
print our_sqrt(our_sqrt(2) + our_sqrt(3)). // 1.77377...
print square(our_sqrt(1000)). // 1000.00000000003
```
Итак, в этой главе демонстрируется, что использование исключительно условных конструкций и вызовов 
функций позволяет решать довольно сложные вычислительные задачи, не вводя таких конструкций как 
присваивание или операторы циклов, знакомых по другим языкам программирования, в которых основным 
является стиль программ, называемый *императивным*.

**Упражнение 1.** Написанная функция `is_good_guess()` не очень эффективна для вычисления квадратного 
корня из очень маленьких чисел. Также, поскольку вычисления в компьютере производятся с конечной 
точностью, она не очень хорошо подходит для больших чисел. Объясните и покажите на примерах, в чём 
заключается неэффективность. Альтернативный подход к остановке итераций состоит в том, чтобы смотреть, 
насколько меняется приближение `guess` между двумя последовательными итерациями, и прекращать 
процедуру тогда, когда изменение составляет малую долю от значения самого приближения `guess`. 
Попробуйте переписать процедуру вычисления квадратного корня, используя это условие остановки. Проверьте, 
улучшает ли это работу функции на больших и маленьких значениях аргумента.

**Упражнение 2.** Как известно, положение тела на эллиптической орбите можно определить через 
[истинную аномалию](https://ru.wikipedia.org/wiki/Элементы_орбиты#Аномалии).Время же, прошедшее с 
последнего прохождения перицентра, определяется [средней аномалией](https://ru.wikipedia.org/wiki/Кеплеровы_элементы_орбиты#Средняя_аномалия). 
Средняя аномалия *M* равна *n*\*(*t*-*t*<sub>Pe</sub>), где 
* *t*<sub>Pe</sub> -- время прохождения через перицентр
* *t* -- текущее время
* *n* -- средняя угловая скорость движения по орбите, или "среднее движение". *n*=(2π радиан)/(период обращения) или 360°/(период обращения).

Истинная аномалия вычисляется в явном виде через эксцентрическую аномалию *E*, которая связана со 
средней аномалией [уравнением Кеплера](https://ru.wikipedia.org/wiki/Уравнение_Кеплера#Эллиптическая_орбита):

*E*-*e*×sin(*E*)=*M*, если *E* и *M* выражены в радианах, или

*E*-(180/π)*e*×sin(*E*)=*M*, если *E* и *M* в градусах,

где *e* -- эксцентриситет орбиты.

Напишите, аналогично вычислению квадратного корня, функцию, вычисляющую эксцентрическую аномалию по заданной средней. 
В kOS углы измеряются в градусах, поэтому пользоваться нужно второй формулой. В качестве начального приближения можно 
взять среднюю аномалию. Возможные варианты "улучшения" приближения:

а) (метод простой итерации) *E*<sub>*k*+1</sub>&nbsp;=&nbsp;*M*+(180/π)*e*×sin(*E<sub>k</sub>*).

б) (метод Ньютона) *E*<sub>*k*+1</sub>&nbsp;=&nbsp;*E<sub>k</sub>*+(*M*+(180/π)*e*×sin(*E<sub>k</sub>*)-*E<sub>k</sub>*)/(1-*e*×cos(*E<sub>k</sub>*)).

В качестве аргументов эта функция должна принимать среднюю аномалию и эксцентриситет орбиты. 
Число π в kOS доступно как `constant:pi`.

[ \>](ch1.7.md)

[\< 1.6. Условные выражения и логические функции](ch1.6.md)

[\<\< К оглавлению](../../README.md)
