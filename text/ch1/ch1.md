# Глава 1. Процедурные абстракции

## 1.1. Первое знакомство с языком
В этой части мы будем знакомиться с базовым синтаксисом kerboscript и начнём знакомство 
со средствами построения выражений, комбинирования базовых элементов для создания более 
сложных конструкций и средств абстракции, позволяющих давать собственные имена таким сложным 
конструкциям и манипулировать ими как отдельными сущностями.

Работа с kerboscript может происходить в двух режимах: интерактивный режим, когда выражения 
и команды набираются в терминале и выполняются, и режим исполнения файла, когда команды считываются 
из файла.

Начнём знакомство с интерактивного режима.

В открытом терминале наберём какое-нибудь число, например
```
> 42.
```
(знаком `>` будут обозначаться строки пользовательского ввода).
Интерпретатор ничего не печатает.
Если набрать
```
hello.
```
то выведется сообщение о том, что переменная с именем "hello" не определена.

Введём команду
```
> print "hello".
```
В ответ будет напечатана строка "hello". Если набрать
```
> print 2.
```
напечатается число 2. А вот команда 
```
> print hello.
```
опять вызывает такую же ошибку о несуществующей переменной.

Можно также набрать 
```
> print 2+3*4.
```
В ответ будет выведено число 14.

Таким образом, выражение после команды `print` сначала вычисляется, а затем выводится в терминал.

Можно попробовать более сложные выражения:
```
> print (3 + 7) * 9^2 * 1.5 - 1.
1214
```
Этот пример показывает, что kerboscript может работать как с целыми числами, так и с числами с плавающей точкой, а при арифметических вычислениях учитывается старшинство операций: возведение в степень (`^`) выполняется раньше умножения и деления, а они, в свою очередь, -- раньше сложения и вычитания. И, как обычно, выражения в скобках вычисляются раньше всех, что можно использовать, если вы не помните, какая математическая операция за какой идёт по старшинству.

Как и в других языках, в kerboscript программист может по желанию присваивать имена вычислительным объектам. 
Говорится, что создается *переменная* с некоторым именем, *значением* которой является вычислительный объект.

Создание переменной, или *связывание* имени переменной с некоторым значением, делается командой `declare` с указанием области видимости связывания `global` или `local`. К областям видимости мы вернёмся позже, сейчас отметим, что в терминале можно создавать только глобально видимые переменные. Таким образом, создание переменной будет выглядеть так:
```
> declare global x is 42.
```
Если теперь набрать команду 
```
> print x.
```
то в терминале выведется число `42`.
```
> print x/2.
```
ожидаемо выводит `21`.

Проверить, связано ли имя с каким-либо значением, можно командой `defined`:
```
> print (defined x).
True
> print (defined not_x).
False
```
Если переменная определена, то её значение может использоваться в других выражениях, а также при вычислении значений, которые присваиваются другим переменным:
```
> declare global radius is 2.
> declare global PI is 3.14.
> declare global circle_area is PI * radius * radius.
> print circle_area.
12.56
```
Таким образом, сложные определения комбинируются из более простых, что является основой построения программных систем.

Заметим, что связывание символа со значением происходит в рамках некоторой области памяти, называемой *окружением*. "Верхний уровень" терминала является *глобальным окружением*, но также при написании сложных программ возможно создавать вложенные окружения различной глубины.

## 1.2. Особенности работы с терминалом и файлами
Последняя последовательность команд из предыдущего раздела имела несколько команд, которые имеют одинаковое начало. Чтобы в терминале не печатать каждый раз команды заново, можно пользоваться историей введённых команд. Перемотка истории идёт стрелками вверх и вниз. Т.е. стрелка вверх возвращает в строку ввода последнюю команду, которую затем можно отредактировать.

Также следует отметить, что язык kerboscript нечувствителен к регистру, т.е. следующие команды приведут к идентичному результату:
```
> declare global PI is 3.14.
> DECLARE GLOBAL pi IS 3.14.
> dEClarE GlObAL pI iS 3.14.
```
и т.д. Далее, в основном, будет использоваться `нижний_регистр` и `CamelCase` для обозначения переменных и функций и `ВЕРХНИЙ_РЕГИСТР` для констант.

В силу ограничений мода, терминал kOS в игре не поддерживает копирование и вставку по *Ctrl+C/Ctrl+V*, из-за чего вводить в него определения не слишком удобно. Возможно, однако, записывать команды в файл и запускать их из файла.

kOS может считывать файлы с любого процессора на текущем корабле, а также из "архива" или "компьютера ЦУПа", который соответствует папке *KSP_install/Ships/Script/* на вашем компьютере.

Локальный диск модуля kOS, с которого запущен терминал, имеет обозначение "1:/", диски других модулей на том же корабле -- "2:/", "3:/" и так далее. Компьютер ЦУПа доступен как "0:/" или "ARCHIVE:/".

Чтобы открыть файл для во внутриигровом редакторе, используется команда `edit(filepath)`, где `filepath` -- это обычно строка, обозначающая путь к файлу. Путь может быть абсолютным, т.е. начинаться с обозначения диска, или относительным, т.е. за начальную точку будет считаться директория, в которой в данный момент программа находится.

Для перехода по директориям используется команда `cd(path)`, где `path` -- также относительный или абсолютный путь к директории, в которую хотим перейти.

Также можно переключиться на другой диск командой `switch to VOLUME_NAME`, где `VOLUME_NAME` -- имя или номер диска (без `:/`). Т.е. команды `switch to 0.`, `switch to ARCHIVE.`, `cd("ARCHIVE:/")` и `cd("0:/").` приводят к одному и тому же: переходу в корневую директорию "архива", т.е., фактически, в папку *Ships/Script/* на вашем компьютере.

Естественно, файлы в папке на физическом компьютере можно редактировать в любом текстовом редакторе, даже не запуская игру. 
Файлы, которые хранятся на внутриигровых виртуальных компьютерах, хранятся внутри сохранений игры индивидуально для каждого корабля в заархивированном виде, поэтому изменять их можно только из внутриигрового редактора. 
Однако их преимущество состоит в том, что они могут считываться и выполняться даже когда корабль в игре не имеет радиосвязи с ЦУПом, в то время как архив в такие моменты становится недоступен. 

Теперь попробуем создать файл.
```
> edit("1:/newfile.ks").
```
откроет внутриигровой текстовый редактор.

В нём введём строку:
```
print "Hello, kOS user".
```
и нажмём "Save" или *Ctrl+S*, что сохранит файл в локальной файловой системе. 
Теперь, чтобы запустить команды в этом файле, наберём в терминале 
```
> runpath("1:/newfile.ks").
```
В ответ получаем
```
Hello, kOS user
Program ended.
```
После вывода сообщения "Program ended" терминал готов к вводу новых команд.

Теперь с помощью текстового редактора на физическом компьюере сделаем файл в папке *Ships/Script/* файл *hello.ks*, в который запишем то же самое, что и в прошлый раз:
```
print "Hello, kOS user".
```
Теперь этот файл можно запустить, набрав
```
> runpath("0:/newfile.ks").
```
Ответ терминала будет таким же, как и в прошлый раз.

В [главе 0](../ch0/ch0.md) рассмотрено создание загрузочного файла -- в этом случае файл автоматически копируется из *Ships/Script/boot* в *1:/boot/* при "выкатке" корабля из ЦВС (но не при загрузке корабля из сохранения или откате к старту!) и запускается при каждой загрузке корабля (т.е. при загрузке сохранений, переходе к кораблю из станции слежения, а также когда корабль не является активным крафтом, но попадает в сферу обсчёта физики для активного).
